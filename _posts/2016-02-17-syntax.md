---
layout: page
title: "Syntax"
category: doc
date: 2016-02-17
order: 2
---

### Comments and Whitespace
Whitespace can be a comment or one or more white spaces.

{% highlight go %}
space : _comment | _ws { _ws } ;
{% endhighlight %}

Comments can be block of line comments

{% highlight go %}
_lineComment : '/' '/' {.} '\n' ;
_blockComment : '/' '*' {. | '*'} '*' '/' ;
_comment : _lineComment | _blockComment ;
{% endhighlight %}

*Examples*
{% highlight go %}
// line comment
/*
    block comment
*/
{% endhighlight %}

Whitespaces are spaces, tabs and newlines
{% highlight go %}
_ws : ' ' | '\t' | '\n' | '\r' ;
{% endhighlight %}

Throughout the rest of this specification the whitespaces have ommited, for the sake of brevity.
Please see the [BNF](https://github.com/katydid/katydid/blob/master/relapse/all.bnf) for the full specification.

### Identifiers

An identifier is a sequence of ascii characters, underscores and numbers starting with an ascii character or underscore.

{% highlight go %}
_upcase : 'A'-'Z' ;
_lowcase : 'a'-'z' ;
_id_char : _upcase | _lowcase | '_' | _decimal_digit ;
_id : (_upcase | _lowcase | '_' ) {_id_char} ;
id : _id ;
{% endhighlight %}

*Examples*
{% highlight go %}
abc
a1B2
_12
A_1_b_2
{% endhighlight %}

### Literals

All literals have been kept as close as possible to their [golang syntax](https://golang.org/ref/spec#Integer_literals) counterparts.

#### Integer literals

An integer literal is a sequences of digits, possibly negative.
For all integer representations including octal and hexidecimal sequences an prefix of `int` and enclosing brackets are required.

{% highlight go %}
_decimal_digit : '0' - '9' ;
_octal_digit : '0' - '7' ;
_hex_digit : '0' - '9' | 'A' - 'F' | 'a' - 'f';

_int_lit     : _decimal_lit | _octal_lit | _hex_lit ;
_decimal_lit : ( '1' - '9' ) { _decimal_digit } ;
_octal_lit   : '0' { _octal_digit } ;
_hex_lit     : '0' ( 'x' | 'X' ) _hex_digit { _hex_digit } ;

_singed_int_lit : ['-'] _int_lit ;

_int : 'i' 'n' 't';
int_lit: _int '(' _singed_int_lit ')' |  '0' | ['-'] _decimal_lit ;
{% endhighlight %}

*Examples*
{% highlight go %}
123
-456
int(123)
int(-456)
int(0x1)
int(07)
{% endhighlight %}

#### Unsigned Integer literals

An unsigned integer literal is an integer literal which is always followed by a prefix of `uint` and enclosed in brackets.

{% highlight go %}
_uint : 'u' 'i' 'n' 't';
uint_lit: _uint '(' _int_lit ')' ;
{% endhighlight %}

*Examples*
{% highlight go %}
uint(123)
uint(456)
{% endhighlight %}

#### Double literals

Floating point numbers need a prefix of `double` and enclosing brackets if no decimals are provided.

{% highlight go %}
_decimals  : _decimal_digit { _decimal_digit } ;
_exponent  : ( 'e' | 'E' ) [ '+' | '-' ] _decimals ;

_float_lit : ( _decimals '.' _decimals _exponent )
            | ( _decimals '.' ( _decimals | _exponent ) )
            | ( _decimals _exponent )
            | ( '.' _decimals [ _exponent ] ) 
            ;

_double : 'd' 'o' 'u' 'b' 'l' 'e' ;
double_lit: _double '(' ['-'] ( _float_lit | _int_lit ) ')' | _float_lit ;
{% endhighlight %}

*Examples*
{% highlight go %}
123.0
double(123)
12.3
12E3
12e-3
.12e+3
{% endhighlight %}

#### String literals

Strings in backticks and double quotes are supported.

{% highlight go %}
_big_u_value      : '\\' 'U' _hex_digit _hex_digit _hex_digit _hex_digit
                            _hex_digit _hex_digit _hex_digit _hex_digit ;
_little_u_value   : '\\' 'u' _hex_digit _hex_digit _hex_digit _hex_digit ;
_hex_byte_u_value   : '\\' 'x' _hex_digit _hex_digit ;

_octal_byte_u_value : '\\' _octal_digit _octal_digit _octal_digit ;
_byte_value       : _octal_byte_u_value | _hex_byte_u_value ;
_raw_string : '`' {.} '`' ;
_escaped_char     : '\\' ( 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\\' | '\'' | '"' ) ;
_unicode_value    : . | _little_u_value | _big_u_value | _escaped_char ;
_interpreted_string : '"' { _unicode_value | _byte_value } '"' ;

string_lit : _raw_string | _interpreted_string ;
{% endhighlight %}

*Examples*
{% highlight go %}
"abc"
`abc`
`a"bc`
"a\"bc"
{% endhighlight %}

#### Bytes literals

Each byte can be a character or an integer literal.
These bytes can be composed into list separated by commas, prefix by `[]byte` and enclosed in curly braces.

{% highlight go %}
_char_lit   : '\'' (_unicode_value | _byte_value) '\'' ;
_byte_elem : _int_lit | _char_lit ;
_bytes : '[' ']' 'b' 'y' 't' 'e' ;
bytes_lit : _bytes '{' { _ws } [ _byte_elem { { _ws } ',' { _ws } _byte_elem } ] { _ws } '}' ;
{% endhighlight %}

*Examples*
{% highlight go %}
[]byte{1, 0xa, 'a'}
[]byte{}
{% endhighlight %}

#### Bool literals

A boolean value is a lowercase true or false word.

{% highlight go %}
Bool
  : "true"
  | "false"
  ;
{% endhighlight %}

*Examples*
{% highlight go %}
true
false
{% endhighlight %}

### Variables

A variable is a dollar followed by a type name.  It specifies which [Decoder](https://godoc.org/github.com/katydid/katydid/serialize#Decoder) method on the parser will be called.

{% highlight go %}
double_var : '$' _double ;
int_var : '$' _int ;
uint_var : '$' _uint ;
bytes_var : '$' _bytes ;
string_var : '$' _string ;
bool_var : '$' _bool ;
{% endhighlight %}

*Examples*
{% highlight php %}
$double
$string
{% endhighlight %}

### Terminal

A terminal is a Variable or a Literal

{% highlight go %}
Terminal
  : Literal
  | Variable
  ;
{% endhighlight %}

### Expression

An expression is either a terminal, list or function.

{% highlight go %}
Expr
  : Terminal
  | Function
  | List
  ;
{% endhighlight %}

## Expressions

Expressions is a comma separated list of expressions.

{% highlight go %}
Exprs
  : Expr
  | Exprs Comma Expr
  ;
{% endhighlight %}

### List

A list is zero or more expressions that are prefixed by a ListType and enclosed by curly braces.

{% highlight go %}
ListType
  : "[]bool"
  | "[]int"
  | "[]uint"
  | "[]double"
  | "[]string"
  | "[][]byte"
  ;

List
  : ListType "{" Exprs "}"
  | ListType "{" "}"
  ;
{% endhighlight %}

*Examples*
{% highlight go %}
[]string{"a", "bc"}
[]int{12, int(3)}
[][]byte{[]byte{0xa}}
[]uint{}
{% endhighlight %}

### Function

A function is an identifier with its arguments enclosed by brakets.

{% highlight go %}
Function
  : id "(" Exprs ")" 
  | id "(" ")"
  ;
{% endhighlight %}

*Examples*
{% highlight go %}
eq(1, $int)
contains($string, "a")
now()
{% endhighlight %}

### Built in Functions

A built in function is a well defined prefix followed by an expression.

{% highlight go %}
BuiltIn
  : "==" Expr 
  | "!=" Expr 
  | "<" Expr 
  | ">" Expr 
  | ">=" Expr 
  | "<=" Expr 
  | "~=" Expr 
  | "*=" Expr 
  | "^=" Expr 
  | "$=" Expr 
  | "::" Expr 
  ;
{% endhighlight %}

*Examples*
{% highlight php %}
== "abc"
> 5
:: $bool
{% endhighlight %}

### Name Expression

A name expression can be:

  * any name indicated by an underscore
  * a specific name, specified by a literal or an identifier
  * anything except the specified name expression, which is specified using an exclamation mark and enclosing brackets.
  * a list of alternative name expressions, which is specified with grouping brackets and delimited with pipe characters.

{% highlight go %}
NameExpr
  : "_"
  | Name
  | "!" "(" NameExpr ")"
  | StartNameChoice
  ;

Name
  : Literal
  | id
  ;

StartNameChoice : "(" NameExpr "|" ContinueNameChoice ")" ;

ContinueNameChoice
  : NameExpr
  | ContinueNameChoice "|" NameExpr
  ;
{% endhighlight %}

*Examples*
{% highlight go %}
name
(name|othername)
!(name)
_
!(name|othername|"another name")
(!(_)|(1|2|2.0))
{% endhighlight %}

## Pattern

A Pattern is the union of all pattern types.

|-----------+----------------------------+-----------------------------|
| symbol    | name                       | example                     |
|:---------:|:--------------------------:|:---------------------------:|
|`->`       | LeafNode                   | `->eq($int, 1)`             |
|[shorthands](http://katydid.github.io/doc/builtin.html#Shorthands) | LeafNode                   | `== 1`                      |
|`*`        | ZAny (Zero or more of anything) |  `*`                   |
|`:`        | TreeNode                   | `A:*`                       |
|`<empty>`  | Empty                      | `A:<empty>`                 |
|`[,]`      | Concat                     | `[A:*, *]`                  |
|`(|)`      | Or                         | `(A:* | B:*)`               |
|`(&)`      | And                        | `(A:* & _ == 1)`            |
|`()*`      | ZeroOrMore                 | `(A == 1)*`                 |
|`# @ =`    | Reference                  | `#main=@a #a=*`             |
|`!()`      | Not                        | `!(A == 1)`                 |
|`.`        | Contains                   | `.A == 1`                   |
|`()?`      | Optional                   | `(A == 1)?`                 |
|`{;}`      | Interleave                 | `{A:*;B:*}`                 |
|-----------+----------------------------+-----------------------------|

The syntactical difference between a Pattern and DepthPattern will be discussed later.
This pattern is equivalent to, but not the same as the one specified in the BNF.
This was done for the sake of keeping it simple, please see the [BNF](https://github.com/katydid/katydid/blob/master/relapse/all.bnf) for a more accurate representation.

{% highlight go %}
Pattern
  : ZAny
  | TreeNode
  | DepthPattern
  | StartOr
  | StartAnd
  | ZeroOrMore
  | Optional
  | Reference
  | Not
  | Empty
  ;

DepthPattern
  : LeafNode
  | StartConcat
  | StartInterleave
  | Contains
  ;
{% endhighlight %}

### ZAny

ZAny specifies zero or more of anything, very much like .* in a regular expression.

{% highlight go %}
ZAny: "*"
{% endhighlight %}

### TreeNode Pattern

A tree node consists of a name and a pattern.

{% highlight go %}
TreeNode
  : NameExpr ":" Pattern
  | NameExpr DepthPattern
  ;
{% endhighlight %}

A DepthPattern has enough syntactical clues to indicate that, given a name expression, a tree node is specified.
Other patterns require a colon between the name expression and the pattern.

*Examples*
{% highlight go %}
name: *
name [a: *, b: *]
name:[a: *, b: *]
{% endhighlight %}

### LeafNode Pattern

A LeafNode applies a function, that returns a boolean, to a value in a tree node with no children.  This can be some type of number, string, bytes or a boolean.  These functions can be composed from other functions, see the [builtin functions](http://katydid.github.io/doc/builtin) or you can even [add your own functions](http://katydid.github.io/dev/addingfunctions).  Specifying some of the builtin functions also has some syntactic sugar.

{% highlight go %}
LeafNode
  : "->" Function
  | BuiltIn
  ;
{% endhighlight %}

*Examples*
{% highlight go %}
== "a"
->eq($int, 1)
{% endhighlight %}

### Empty

Empty is used internally to indicate that the pattern has been satisfied.
It is also useful in the specification of XML trees.

{% highlight php %}
Empty: "<empty>"
{% endhighlight %}

### Concat

Concat is used to describe an ordered sequence of patterns.
This is done by concatenating 2 or more patterns together.

{% highlight go %}
StartConcat
  : "[" Pattern "," ContinueConcat "]"
  | "[" Pattern "," ContinueConcat "," "]"
  ;

ContinueConcat
  : Pattern
  | ContinueConcat "," Pattern
  ;
{% endhighlight %}

*Examples*
{% highlight go %}
[a: *, b: *]
[
  a: *,
  b: *,
  c: *,
]
{% endhighlight %}

### Interleave

Interleave is used to describe an unordered sequence of patterns.

{% highlight go %}
StartInterleave
  : "{" Pattern ";" ContinueInterleave "}"
  | "{" Pattern ";" ContinueInterleave ";" "}"
  ;

ContinueInterleave
  : Pattern
  | ContinueInterleave ";" Pattern
  ;
{% endhighlight %}

*Examples*
{% highlight go %}
{a: *; b: *}
{
  a: *;
  b: *;
  c: *;
}
{% endhighlight %}

### Contains

Contains only cares about satisfying one pattern in sequence of nodes.
It is a shorthand used for selective filtering and is equivalent to `[*, Pattern, *]`.

{% highlight go %}
Contains: "." Pattern;
{% endhighlight %}

*Examples*
{% highlight go %}
.a:*
.a.b.c == 1
{% endhighlight %}

### Or

Or specifies a list of alternative patterns.

{% highlight go %}
StartOr
  : "(" Pattern "|" ContinueOr ")"
  ;

ContinueOr
  : Pattern
  | ContinueOr "|" Pattern
  ;
{% endhighlight %}

*Examples*
{% highlight go %}
(a:*|b:*)
(a:<empty> | b == 1 | c:*)
{% endhighlight %}

### And

And specifies a list of intersecting patterns.

{% highlight go %}
StartAnd
  : "(" Pattern "&" ContinueAnd ")"
  ;

ContinueAnd
  : Pattern
  | ContinueAnd "&" Pattern
  ;
{% endhighlight %}

*Examples*
{% highlight go %}
(a:*&_ == b)
(a == 1 & _ == 1 & a:*)
{% endhighlight %}

### ZeroOrMore

ZeroOrMore specifies a repeated pattern that repeats zero or more times.

{% highlight go %}
ZeroOrMore: "(" Pattern ")" "*" ;
{% endhighlight %}

*Examples*
{% highlight go %}
(a:*)*
([a:*, b:*])*
{% endhighlight %}

### Optional

Optional is syntactic sugar for `(Pattern|<empty>)`

{% highlight go %}
Optiona: "(" Pattern ")" "?" 
{% endhighlight %}

*Examples*
{% highlight go %}
(a:*)?
{(a:*)?;b:*}
{% endhighlight %}

### Not

Not is used to take the complement of a pattern.

{% highlight go %}
Not: "!" "(" Pattern ")" ;
{% endhighlight %}

*Examples*
{% highlight go %}
!(a:*)
!(*)
{% endhighlight %}

### Reference

Reference is used as an in place reference to a predefined pattern or pattern declaration.

{% highlight go %}
Reference: "@" id ;
{% endhighlight %}

*Examples*
{% highlight go %}
@main
@myref
{% endhighlight %}

## Grammar

A grammar consists of a list of pattern declarations.
A pattern declaration consists of an name and a pattern.
A grammar can start with one pattern which does not have a name.
It is implied that this first pattern's name is main.

{% highlight go %}
Grammar
  : Pattern                   
  | Pattern PatternDecls        
  | PatternDecls                
  ;

PatternDecls
  : PatternDecl               
  | PatternDecls PatternDecl
  ;

PatternDecl : "#" id "=" Pattern ;
{% endhighlight %}

*Examples*
{% highlight go %}
A:*

#main = A:*

A:(@main|<empty>)

A: @myref
#myref = @myref2
#myref2 = <empty>
{% endhighlight %}

# BNF

Dragons can view the BNF source [here](https://github.com/katydid/katydid/blob/master/relapse/all.bnf)