---
layout: page
title: "Syntax"
category: doc
date: 2016-02-17
order: 5
---

### Comments and Whitespace
Whitespace can be a comment or one or more white spaces.

{% highlight go %}
space : _comment | _ws { _ws } ;
{% endhighlight %}

Comments can be block of line comments

{% highlight go %}
_lineComment : '/' '/' {.} '\n' ;
_blockComment : '/' '*' {. | '*'} '*' '/' ;
_comment : _lineComment | _blockComment ;
{% endhighlight %}

*Examples*
{% highlight go %}
// line comment
/*
    block comment
*/
{% endhighlight %}

Whitespaces are spaces, tabs and newlines
{% highlight go %}
_ws : ' ' | '\t' | '\n' | '\r' ;
{% endhighlight %}

Throughout the rest of this specification the whitespaces have ommited, for the sake of brevity.
Please see the [BNF](https://github.com/katydid/katydid/blob/master/relapse/all.bnf) for the full specification.

### Identifiers

An identifier is a sequence of ascii characters, underscores and numbers starting with an ascii character or underscore.

{% highlight go %}
_upcase : 'A'-'Z' ;
_lowcase : 'a'-'z' ;
_id_char : _upcase | _lowcase | '_' | _decimal_digit ;
_id : (_upcase | _lowcase | '_' ) {_id_char} ;
id : _id ;
{% endhighlight %}

*Examples*
{% highlight go %}
abc
a1B2
_12
A_1_b_2
{% endhighlight %}

### Literals

All literals have been kept as close as possible to their [golang syntax](https://golang.org/ref/spec#Integer_literals) counterparts.

#### Integer literals

An integer literal is a sequences of digits, possibly negative.
For all integer representations including octal and hexidecimal sequences an prefix of `int` and enclosing brackets are required.

{% highlight go %}
_decimal_digit : '0' - '9' ;
_octal_digit : '0' - '7' ;
_hex_digit : '0' - '9' | 'A' - 'F' | 'a' - 'f';

_int_lit     : _decimal_lit | _octal_lit | _hex_lit ;
_decimal_lit : ( '1' - '9' ) { _decimal_digit } ;
_octal_lit   : '0' { _octal_digit } ;
_hex_lit     : '0' ( 'x' | 'X' ) _hex_digit { _hex_digit } ;

_singed_int_lit : ['-'] _int_lit ;

_int : 'i' 'n' 't';
int_lit: _int '(' _singed_int_lit ')' |  '0' | ['-'] _decimal_lit ;
{% endhighlight %}

*Examples*
{% highlight go %}
123
-456
int(123)
int(-456)
int(0x1)
int(07)
{% endhighlight %}

#### Unsigned Integer literals

An unsigned integer literal is an integer literal which is always followed by a prefix of `uint` and enclosed in brackets.

{% highlight go %}
_uint : 'u' 'i' 'n' 't';
uint_lit: _uint '(' _int_lit ')' ;
{% endhighlight %}

*Examples*
{% highlight go %}
uint(123)
uint(456)
{% endhighlight %}

#### Double literals

Floating point numbers need a prefix of `double` and enclosing brackets if no decimals are provided.

{% highlight go %}
_decimals  : _decimal_digit { _decimal_digit } ;
_exponent  : ( 'e' | 'E' ) [ '+' | '-' ] _decimals ;

_float_lit : ( _decimals '.' _decimals _exponent )
            | ( _decimals '.' ( _decimals | _exponent ) )
            | ( _decimals _exponent )
            | ( '.' _decimals [ _exponent ] ) 
            ;

_double : 'd' 'o' 'u' 'b' 'l' 'e' ;
double_lit: _double '(' ['-'] ( _float_lit | _int_lit ) ')' | _float_lit ;
{% endhighlight %}

*Examples*
{% highlight go %}
123.0
double(123)
12.3
12E3
12e-3
.12e+3
{% endhighlight %}

#### String literals

Strings in backticks and double quotes are supported.

{% highlight go %}
_big_u_value      : '\\' 'U' _hex_digit _hex_digit _hex_digit _hex_digit
                            _hex_digit _hex_digit _hex_digit _hex_digit ;
_little_u_value   : '\\' 'u' _hex_digit _hex_digit _hex_digit _hex_digit ;
_hex_byte_u_value   : '\\' 'x' _hex_digit _hex_digit ;

_octal_byte_u_value : '\\' _octal_digit _octal_digit _octal_digit ;
_byte_value       : _octal_byte_u_value | _hex_byte_u_value ;
_raw_string : '`' {.} '`' ;
_escaped_char     : '\\' ( 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\\' | '\'' | '"' ) ;
_unicode_value    : . | _little_u_value | _big_u_value | _escaped_char ;
_interpreted_string : '"' { _unicode_value | _byte_value } '"' ;

string_lit : _raw_string | _interpreted_string ;
{% endhighlight %}

*Examples*
{% highlight go %}
"abc"
`abc`
`a"bc`
"a\"bc"
{% endhighlight %}

#### Bytes literals

Each byte can be a character or an integer literal.
These bytes can be composed into list separated by commas, prefix by `[]byte` and enclosed in curly braces.

{% highlight go %}
_char_lit   : '\'' (_unicode_value | _byte_value) '\'' ;
_byte_elem : _int_lit | _char_lit ;
_bytes : '[' ']' 'b' 'y' 't' 'e' ;
bytes_lit : _bytes '{' { _ws } [ _byte_elem { { _ws } ',' { _ws } _byte_elem } ] { _ws } '}' ;
{% endhighlight %}

*Examples*
{% highlight go %}
[]byte{1, 0xa, 'a'}
[]byte{}
{% endhighlight %}

#### Bool literals

A boolean value is a lowercase true or false word.

{% highlight go %}
Bool
  : "true"
  | "false"
  ;
{% endhighlight %}

*Examples*
{% highlight go %}
true
false
{% endhighlight %}

### Variables

A variable is a dollar followed by a type name.  It specifies which [Decoder](https://godoc.org/github.com/katydid/katydid/serialize#Decoder) method on the parser will be called.

{% highlight go %}
double_var : '$' _double ;
int_var : '$' _int ;
uint_var : '$' _uint ;
bytes_var : '$' _bytes ;
string_var : '$' _string ;
bool_var : '$' _bool ;
{% endhighlight %}

*Examples*
{% highlight php %}
$double
$string
{% endhighlight %}

### Terminal

A terminal is a Variable or a Literal

{% highlight go %}
Terminal
  : Literal
  | Variable
  ;
{% endhighlight %}

### Expression

An expression is either a terminal, list or function.

{% highlight go %}
Expr
  : Terminal
  | Function
  | List
  ;
{% endhighlight %}

### Lists

A list is zero or more expressions that are prefixed by a ListType and enclosed by curly braces.

{% highlight go %}
ListType
  : "[]bool"
  | "[]int"
  | "[]uint"
  | "[]double"
  | "[]string"
  | "[][]byte"
  ;

List
  : ListType "{" Exprs "}"
  | ListType "{" "}"
  ;
{% endhighlight %}

*Examples*
{% highlight go %}
[]string{"a", "bc"}
[]int{12, int(3)}
[][]byte{[]byte{0xa}}
[]uint{}
{% endhighlight %}

### Function

A function is an identifier with its arguments enclosed by brakets.

{% highlight go %}
Function
  : id "(" Exprs ")" 
  | id "(" ")"
  ;
{% endhighlight %}

*Examples*
{% highlight go %}
eq(1, $int)
contains($string, "a")
now()
{% endhighlight %}

### Built in Functions

A built in function is a well defined prefix followed by an expression.

{% highlight go %}
BuiltIn
  : "==" Expr 
  | "!=" Expr 
  | "<" Expr 
  | ">" Expr 
  | ">=" Expr 
  | "<=" Expr 
  | "~=" Expr 
  | "*=" Expr 
  | "^=" Expr 
  | "$=" Expr 
  | "::" Expr 
  ;
{% endhighlight %}

*Examples*
{% highlight php %}
== "abc"
> 5
:: $bool
{% endhighlight %}

## Operators

The Relapse language consists of several operators:

|-----------+----------------------------+---------------------------|
| symbol    | name                       | example                   |
|:---------:|:--------------------------:|:-------------------------:|
|`->`       | LeafNode                   | `->eq($int, 1)`           |
|[shorthands](http://katydid.github.io/doc/builtin.html#Shorthands) | LeafNode                   | `== 1`                      |
|`*`        | ZAny (Zero or more of anything) |  `*`                  |
|`:`        | TreeNode                   | `A:*`                       |
|`<empty>`  | Empty                      | `A:<empty>`                 |
|`[,]`      | Concat                     | `[A:*, *]`                  |
|`(|)`      | Or                         | `(A:* | B:*)`               |
|`(&)`      | And                        | `(A:* & _ == 1)`            |
|`()*`      | ZeroOrMore                 | `(A == 1)*`                 |
|`# @ =`    | Reference                  | `#main=@a #a=*`             |
|`!()`      | Not                        | `!(A == 1)`                 |
|`.`        | Contains                   | `.A == 1`                   |
|`()?`      | Optional                   | `(A == 1)?`                 |
|`{;}`      | Interleave                 | `{A:*;B:*}`                 |
|-----------+----------------------------+---------------------------|

### LeafNode

A LeafNode applies a function, that returns a boolean, to a value in a tree node with no children.  This can be some type of number, string, bytes or a boolean.  These functions can be composed from other functions, see the [builtin functions](http://katydid.github.io/doc/builtin) or you can even [add your own functions](http://katydid.github.io/dev/addingfunctions).  Specifying some of the builtin functions also has some syntactic sugar.

### ZAny

*Work in Progress*

### TreeNode

*Work in Progress*

#### Names

*Work in Progress*

### Empty

*Work in Progress*

### Concat

*Work in Progress*

### Or

*Work in Progress*

### And

*Work in Progress*

### ZeroOrMore

*Work in Progress*

### Reference

*Work in Progress*

### Not

*Work in Progress*

### Contains

*Work in Progress*

### Optional

*Work in Progress*

### Interleave

*Work in Progress*


# BNF

Dragons can view the BNF source [here](https://github.com/katydid/katydid/blob/master/relapse/all.bnf)