---
layout: page
title: "Syntax"
category: doc
date: 2016-02-17
order: 2
---

### Comments and Whitespace
Whitespace can be a comment or one or more white spaces.

{% highlight antlr %}
space : _comment | _ws { _ws } ;
{% endhighlight %}

Comments can be block of line comments

{% highlight antlr %}
_lineComment : '/' '/' {.} '\n' ;
_blockComment : '/' '*' {. | '*'} '*' '/' ;
_comment : _lineComment | _blockComment ;
{% endhighlight %}

*Examples*
{% highlight antlr %}
// line comment
/*
    block comment
*/
{% endhighlight %}

White spaces are space characters, tabs and newlines
{% highlight antlr %}
_ws : ' ' | '\t' | '\n' | '\r' ;
{% endhighlight %}

Throughout the rest of this specification the white spaces have omitted, for the sake of brevity.
Please see the [BNF](https://github.com/katydid/katydid/blob/master/relapse/all.bnf) for the full specification.

### Identifiers

An identifier is a sequence of ASCII characters, underscores and numbers starting with an ASCII character or underscore.

{% highlight antlr %}
_upcase : 'A'-'Z' ;
_lowcase : 'a'-'z' ;
_id_char : _upcase | _lowcase | '_' | _decimal_digit ;
_id : (_upcase | _lowcase | '_' ) {_id_char} ;
id : _id ;
{% endhighlight %}

*Examples*
{% highlight antlr %}
abc
a1B2
_12
A_1_b_2
{% endhighlight %}

### Literals

All literals have been kept as close as possible to their [golang syntax](https://golang.org/ref/spec#Integer_literals) counterparts.

#### Integer literals

An integer literal is a sequences of digits, possibly negative.
For all integer representations including octal and hexadecimal sequences an prefix of `int` and enclosing brackets are required.

{% highlight antlr %}
_decimal_digit : '0' - '9' ;
_octal_digit : '0' - '7' ;
_hex_digit : '0' - '9' | 'A' - 'F' | 'a' - 'f';

_int_lit     : _decimal_lit | _octal_lit | _hex_lit ;
_decimal_lit : ( '1' - '9' ) { _decimal_digit } ;
_octal_lit   : '0' { _octal_digit } ;
_hex_lit     : '0' ( 'x' | 'X' ) _hex_digit { _hex_digit } ;

_singed_int_lit : ['-'] _int_lit ;

_int : 'i' 'n' 't';
int_lit: _int '(' _singed_int_lit ')' |  '0' | ['-'] _decimal_lit ;
{% endhighlight %}

*Examples*
{% highlight antlr %}
123
-456
int(123)
int(-456)
int(0x1)
int(07)
{% endhighlight %}

#### Unsigned Integer literals

An unsigned integer literal is an integer literal which is always followed by a prefix of `uint` and enclosed in brackets.

{% highlight antlr %}
_uint : 'u' 'i' 'n' 't';
uint_lit: _uint '(' _int_lit ')' ;
{% endhighlight %}

*Examples*
{% highlight antlr %}
uint(123)
uint(456)
{% endhighlight %}

#### Double literals

Floating point numbers need a prefix of `double` and enclosing brackets if no decimals are provided.

{% highlight antlr %}
_decimals  : _decimal_digit { _decimal_digit } ;
_exponent  : ( 'e' | 'E' ) [ '+' | '-' ] _decimals ;

_float_lit : ( _decimals '.' _decimals _exponent )
            | ( _decimals '.' ( _decimals | _exponent ) )
            | ( _decimals _exponent )
            | ( '.' _decimals [ _exponent ] ) 
            ;

_double : 'd' 'o' 'u' 'b' 'l' 'e' ;
double_lit: _double '(' ['-'] ( _float_lit | _int_lit ) ')' | _float_lit ;
{% endhighlight %}

*Examples*
{% highlight antlr %}
123.0
double(123)
12.3
12E3
12e-3
.12e+3
{% endhighlight %}

#### String literals

Strings in back ticks and double quotes are supported.

{% highlight antlr %}
_big_u_value      : '\\' 'U' _hex_digit _hex_digit _hex_digit _hex_digit
                            _hex_digit _hex_digit _hex_digit _hex_digit ;
_little_u_value   : '\\' 'u' _hex_digit _hex_digit _hex_digit _hex_digit ;
_hex_byte_u_value   : '\\' 'x' _hex_digit _hex_digit ;

_octal_byte_u_value : '\\' _octal_digit _octal_digit _octal_digit ;
_byte_value       : _octal_byte_u_value | _hex_byte_u_value ;
_raw_string : '`' {.} '`' ;
_escaped_char     : '\\' ( 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\\' | '\'' | '"' ) ;
_unicode_value    : . | _little_u_value | _big_u_value | _escaped_char ;
_interpreted_string : '"' { _unicode_value | _byte_value } '"' ;

string_lit : _raw_string | _interpreted_string ;
{% endhighlight %}

*Examples*
{% highlight antlr %}
"abc"
`abc`
`a"bc`
"a\"bc"
{% endhighlight %}

#### Bytes literals

Each byte can be a character or an integer literal.
These bytes can be composed into list separated by commas, prefix by `[]byte` and enclosed in curly braces.

{% highlight antlr %}
_char_lit   : '\'' (_unicode_value | _byte_value) '\'' ;
_byte_elem : _int_lit | _char_lit ;
_bytes : '[' ']' 'b' 'y' 't' 'e' ;
bytes_lit : _bytes '{' { _ws } [ _byte_elem { { _ws } ',' { _ws } _byte_elem } ] { _ws } '}' ;
{% endhighlight %}

*Examples*
{% highlight antlr %}
[]byte{1, 0xa, 'a'}
[]byte{}
{% endhighlight %}

#### Boolean literals

A boolean value is a lowercase true or false word.

{% highlight antlr %}
Bool
  : "true"
  | "false"
  ;
{% endhighlight %}

*Examples*
{% highlight antlr %}
true
false
{% endhighlight %}

### Variables

A variable is a dollar followed by a type name.  It specifies which [Decoder](https://godoc.org/github.com/katydid/katydid/serialize#Decoder) method on the parser will be called.

{% highlight antlr %}
double_var : '$' _double ;
int_var : '$' _int ;
uint_var : '$' _uint ;
bytes_var : '$' _bytes ;
string_var : '$' _string ;
bool_var : '$' _bool ;
{% endhighlight %}

*Examples*
{% highlight antlr %}
$double
$string
{% endhighlight %}

### Terminal

A terminal is a Variable or a Literal

{% highlight antlr %}
Terminal
  : Literal
  | Variable
  ;
{% endhighlight %}

### Expression

An expression is either a terminal, list or function.

{% highlight antlr %}
Expr
  : Terminal
  | Function
  | List
  ;
{% endhighlight %}

## Expressions

Expressions is a comma separated list of expressions.

{% highlight antlr %}
Exprs
  : Expr
  | Exprs Comma Expr
  ;
{% endhighlight %}

### List

A list is zero or more expressions that are prefixed by a ListType and enclosed by curly braces.

{% highlight antlr %}
ListType
  : "[]bool"
  | "[]int"
  | "[]uint"
  | "[]double"
  | "[]string"
  | "[][]byte"
  ;

List
  : ListType "{" Exprs "}"
  | ListType "{" "}"
  ;
{% endhighlight %}

*Examples*
{% highlight antlr %}
[]string{"a", "bc"}
[]int{12, int(3)}
[][]byte{[]byte{0xa}}
[]uint{}
{% endhighlight %}

### Function

A function is an identifier with its arguments enclosed by brackets.

{% highlight antlr %}
Function
  : id "(" Exprs ")" 
  | id "(" ")"
  ;
{% endhighlight %}

*Examples*
{% highlight antlr %}
eq(1, $int)
contains($string, "a")
now()
{% endhighlight %}

### Built in Functions

A built in function is a well defined prefix followed by an expression.

{% highlight antlr %}
BuiltIn
  : "==" Expr 
  | "!=" Expr 
  | "<" Expr 
  | ">" Expr 
  | ">=" Expr 
  | "<=" Expr 
  | "~=" Expr 
  | "*=" Expr 
  | "^=" Expr 
  | "$=" Expr 
  | "::" Expr 
  ;
{% endhighlight %}

*Examples*
{% highlight antlr %}
== "abc"
> 5
:: $bool
{% endhighlight %}

### Name Expression

A name expression can be:

  * any name indicated by an underscore
  * a specific name, specified by a literal or an identifier
  * anything except the specified name expression, which is specified using an exclamation mark and enclosing brackets.
  * a list of alternative name expressions, which is specified with grouping brackets and delimited with pipe characters.

{% highlight antlr %}
NameExpr
  : "_"
  | Name
  | "!" "(" NameExpr ")"
  | StartNameChoice
  ;

Name
  : Literal
  | id
  ;

StartNameChoice : "(" NameExpr "|" ContinueNameChoice ")" ;

ContinueNameChoice
  : NameExpr
  | ContinueNameChoice "|" NameExpr
  ;
{% endhighlight %}

*Examples*
{% highlight antlr %}
name
(name|othername)
!(name)
_
!(name|othername|"another name")
(!(_)|(1|2|2.0))
{% endhighlight %}

## Pattern

A Pattern is the union of all pattern types.

|-----------+----------------------------+-----------------------------|
| symbol    | name                       | example                     |
|:---------:|:--------------------------:|:---------------------------:|
|`->`       | LeafNode                   | `->eq($int, 1)`             |
|[shorthands](http://katydid.github.io/doc/builtin.html#Shorthands) | LeafNode                   | `== 1`                      |
|`*`        | ZAny (Zero or more of anything) |  `*`                   |
|`:`        | TreeNode                   | `A:*`                       |
|`<empty>`  | Empty                      | `A:<empty>`                 |
|`[,]`      | Concat                     | `[A:*, *]`                  |
|`(|)`      | Or                         | `(A:* | B:*)`               |
|`(&)`      | And                        | `(A:* & _ == 1)`            |
|`()*`      | ZeroOrMore                 | `(A == 1)*`                 |
|`# @ =`    | Reference                  | `#main=@a #a=*`             |
|`!()`      | Not                        | `!(A == 1)`                 |
|`.`        | Contains                   | `.A == 1`                   |
|`()?`      | Optional                   | `(A == 1)?`                 |
|`{;}`      | Interleave                 | `{A:*;B:*}`                 |
|-----------+----------------------------+-----------------------------|

The syntactical difference between a Pattern and DepthPattern will be discussed later.
This pattern is equivalent to, but not the same as the one specified in the BNF.
This was done for the sake of keeping it simple, please see the [BNF](https://github.com/katydid/katydid/blob/master/relapse/all.bnf) for a more accurate representation.

{% highlight antlr %}
Pattern
  : ZAny
  | TreeNode
  | DepthPattern
  | StartOr
  | StartAnd
  | ZeroOrMore
  | Optional
  | Reference
  | Not
  | Empty
  ;

DepthPattern
  : LeafNode
  | StartConcat
  | StartInterleave
  | Contains
  ;
{% endhighlight %}

### ZAny

ZAny specifies zero or more of anything, very much like .* in a regular expression.

{% highlight antlr %}
ZAny: "*"
{% endhighlight %}

### TreeNode Pattern

A tree node consists of a name and a pattern.

{% highlight antlr %}
TreeNode
  : NameExpr ":" Pattern
  | NameExpr DepthPattern
  ;
{% endhighlight %}

A DepthPattern has enough syntactical clues to indicate that, given a name expression, a tree node is specified.
Other patterns require a colon between the name expression and the pattern.

*Examples*
{% highlight antlr %}
name: *
name [a: *, b: *]
name:[a: *, b: *]
{% endhighlight %}

### LeafNode Pattern

A LeafNode applies a function, that returns a boolean, to a value in a tree node with no children.  This can be some type of number, string, bytes or a boolean.  These functions can be composed from other functions, see the [built in functions](http://katydid.github.io/doc/builtin) or you can even [add your own functions](http://katydid.github.io/dev/addingfunctions).  Specifying some of the built in functions also has some syntactic sugar.

{% highlight antlr %}
LeafNode
  : "->" Function
  | BuiltIn
  ;
{% endhighlight %}

*Examples*
{% highlight antlr %}
== "a"
->eq($int, 1)
{% endhighlight %}

### Empty

Empty is used internally to indicate that the pattern has been satisfied.
It is also useful in the specification of XML trees.

{% highlight antlr %}
Empty: "<empty>"
{% endhighlight %}

### Concat

Concat is used to describe an ordered sequence of patterns.
This is done by concatenating 2 or more patterns together.

{% highlight antlr %}
StartConcat
  : "[" Pattern "," ContinueConcat "]"
  | "[" Pattern "," ContinueConcat "," "]"
  ;

ContinueConcat
  : Pattern
  | ContinueConcat "," Pattern
  ;
{% endhighlight %}

*Examples*
{% highlight antlr %}
[a: *, b: *]
[
  a: *,
  b: *,
  c: *,
]
{% endhighlight %}

### Interleave

Interleave is used to describe an unordered sequence of patterns.

{% highlight antlr %}
StartInterleave
  : "{" Pattern ";" ContinueInterleave "}"
  | "{" Pattern ";" ContinueInterleave ";" "}"
  ;

ContinueInterleave
  : Pattern
  | ContinueInterleave ";" Pattern
  ;
{% endhighlight %}

*Examples*
{% highlight antlr %}
{a: *; b: *}
{
  a: *;
  b: *;
  c: *;
}
{% endhighlight %}

### Contains

Contains only cares about satisfying one pattern in sequence of nodes.
It is a shorthand used for selective filtering and is equivalent to `[*, Pattern, *]`.

{% highlight antlr %}
Contains: "." Pattern;
{% endhighlight %}

*Examples*
{% highlight antlr %}
.a:*
.a.b.c == 1
{% endhighlight %}

### Or

Or specifies a list of alternative patterns.

{% highlight antlr %}
StartOr
  : "(" Pattern "|" ContinueOr ")"
  ;

ContinueOr
  : Pattern
  | ContinueOr "|" Pattern
  ;
{% endhighlight %}

*Examples*
{% highlight antlr %}
(a:*|b:*)
(a:<empty> | b == 1 | c:*)
{% endhighlight %}

### And

And specifies a list of intersecting patterns.

{% highlight antlr %}
StartAnd
  : "(" Pattern "&" ContinueAnd ")"
  ;

ContinueAnd
  : Pattern
  | ContinueAnd "&" Pattern
  ;
{% endhighlight %}

*Examples*
{% highlight antlr %}
(a:*&_ == b)
(a == 1 & _ == 1 & a:*)
{% endhighlight %}

### ZeroOrMore

ZeroOrMore specifies a repeated pattern that repeats zero or more times.

{% highlight antlr %}
ZeroOrMore: "(" Pattern ")" "*" ;
{% endhighlight %}

*Examples*
{% highlight antlr %}
(a:*)*
([a:*, b:*])*
{% endhighlight %}

### Optional

Optional is syntactic sugar for `(Pattern|<empty>)`

{% highlight antlr %}
Optiona: "(" Pattern ")" "?" 
{% endhighlight %}

*Examples*
{% highlight antlr %}
(a:*)?
{(a:*)?;b:*}
{% endhighlight %}

### Not

Not is used to take the complement of a pattern.

{% highlight antlr %}
Not: "!" "(" Pattern ")" ;
{% endhighlight %}

*Examples*
{% highlight antlr %}
!(a:*)
!(*)
{% endhighlight %}

### Reference

Reference is used as an in place reference to a predefined pattern or pattern declaration.

{% highlight antlr %}
Reference: "@" id ;
{% endhighlight %}

*Examples*
{% highlight antlr %}
@main
@myref
{% endhighlight %}

## Grammar

A grammar consists of a list of pattern declarations.
A pattern declaration consists of an name and a pattern.
A grammar can start with one pattern which does not have a name.
It is implied that this first pattern's name is main.

{% highlight antlr %}
Grammar
  : Pattern                   
  | Pattern PatternDecls        
  | PatternDecls                
  ;

PatternDecls
  : PatternDecl               
  | PatternDecls PatternDecl
  ;

PatternDecl : "#" id "=" Pattern ;
{% endhighlight %}

*Examples*
{% highlight antlr %}
A:*

#main = A:*

A:(@main|<empty>)

A: @myref
#myref = @myref2
#myref2 = <empty>
{% endhighlight %}

# BNF

Dragons can view the BNF source [here](https://github.com/katydid/katydid/blob/master/relapse/all.bnf)