---
layout: page
title: "Usage"
category: doc
date: 2016-02-17
order: 1
---

This page will explain how to go from a Relapse grammar to validating a tree.
This is done in three steps, which each have many alternatives.

  1. Construct the Grammar
  2. Construct the Parser
  3. Validation

### Constructing a Relapse Grammar

First we need to parse our relapse string into a grammar.
This is perfect for when we are receiving a string from the user or a config file.

{% highlight go %}
import "github.com/katydid/katydid/relapse/parser"

func main() {
	relapseString := "a:*"
	relapseGrammar, err := parser.ParseGrammar(relapseString)
	if err != nil {
		panic(err)
	}
}
{% endhighlight %}

We could also have programmatically constructed our grammar.
This is nice, since then we don't have to worry about syntactical changes in the relapse language.

{% highlight go %}
import "github.com/katydid/katydid/relapse/ast"

func main() {
	relapsePattern := relapse.NewTreeNode(relapse.NewStringName("a"), relapse.NewZAny())
	relapseRefs := map[string]*relapse.Pattern{"main": relapsePattern}
	relapseGrammar := relapse.NewGrammar(relapseRefs)
}
{% endhighlight %}

This can become quite verbose, so we could rather use the combinator library with which we can more concisely, but still programmatically construct the grammar.

{% highlight go %}
import . "github.com/katydid/katydid/relapse/combinator"

func main() {
	relapsePattern := In("a", Any())
	g := G{"main": relapsePattern}
	relapseGrammar := g.Grammar()
}
{% endhighlight %}

When we use this with the funcs library we can get type safe combinations of the funcs.

{% highlight go %}
import . "github.com/katydid/katydid/relapse/combinator"
import . "github.com/katydid/katydid/funcs"

func main() {
	expr := NewStringEqual(NewStringVar(), NewStringConst("abc"))
	relapsePattern := In("a", Value(expr))
	g := G{"main": relapsePattern}
	relapseGrammar := g.Grammar()
}
{% endhighlight %}

### Constructing a Parser

A parser parses a specific serialization format or other parsable text or bytes.
We need to put our unparsed text, bytes or other structure into a parser so that it can be validated.

{% highlight go %}
import "github.com/katydid/katydid/serialize/json"

func main() {
	jsonString := `{"a": "abc"}`
	jsonParser := json.NewJsonParser()
	if err := jsonParser.Init([]byte(jsonString)); err != nil {
		panic(err)
	}
}
{% endhighlight %}

We can also construct a protocol buffer parser.

{% highlight go %}
import protoparser "github.com/katydid/katydid/serialize/proto"
import "github.com/gogo/protobuf/proto"

func main() {
	protoParser := protoparser.NewProtoParser("mypackage", "mymessage", &Mymessage{}.Description())
	msg := &Mymessage{A: "abc"}
	data, err := proto.Marshal(msg)
	if err != nil {
		panic(err)
	}
	if err := protoParser.Init(data); err != nil {
		panic(err)
	}
}
{% endhighlight %}

We can even construct a parser for a reflected go structure.

{% highlight go %}
import reflectparser "github.com/katydid/katydid/serialize/reflect"
import "reflect"

func main() {
	reflectParser := reflectparser.NewReflectParser()
	s := &MyStruct{A: "abc"}
	v := reflect.ValueOf(s)
	reflectParser.Init(v)
}
{% endhighlight %}

### Validation

Now that we have a initialized parser and a relapse grammar we can validate the parsed tree against the schema.

{% highlight go %}
import "github.com/katydid/katydid/relapse/convert"
import "github.com/katydid/katydid/relapse/ast"
import "github.com/katydid/katydid/serialize"
import "fmt"

func validate(grammar *relapse.Grammar, parser serialize.Parser) {
	compiled := convert.Compile(grammar)
	match := convert.Interpret(compiled, parser)
	if !match {
		fmt.Printf("Expected match given %s\n", grammar.String())
	}
}
{% endhighlight %}