---
layout: page
title: "Usage"
category: doc
date: 2016-02-17
order: 1
---

This page will explain how to go from a Relapse grammar to validating a parsed tree.
This is done in three steps.
Each of these steps have several alternatives.

  1. Construct the Grammar
  2. Construct the Parser
  3. Validation

### Constructing a Relapse Grammar

First we need to parse our relapse string into a grammar.
This is perfect for when we are receiving a string from the user or a configuration file.

{% highlight go %}
import "github.com/katydid/katydid/relapse/parser"

func main() {
	relapseString := "a:*"
	relapseGrammar, err := parser.ParseGrammar(relapseString)
	if err != nil {
		panic(err)
	}
}
{% endhighlight %}

If you don't understand the relapseString's value it might be good idea to first take the [Relapse Tour](http://katydid.github.io/tour).

We could also have programmatically constructed our grammar.
This is nice, since the go compiler can help us avoid some errors.

{% highlight go %}
import "github.com/katydid/katydid/relapse"
import "github.com/katydid/katydid/expr"

func main() {
	relapsePattern := relapse.NewTreeNode(expr.NewStringName("a"), relapse.NewZAny())
	relapseRefs := map[string]*relapse.Pattern{"main": relapsePattern}
	relapseGrammar := relapse.NewGrammar(relapseRefs)
}
{% endhighlight %}

This can become quite verbose, so we can rather use the combinator library, with which we can more concisely, but still programmatically, construct the grammar.

{% highlight go %}
import . "github.com/katydid/katydid/relapse/combinator"

func main() {
	relapsePattern := In("a", Any())
	g := G{"main": relapsePattern}
	relapseGrammar := g.Grammar()
}
{% endhighlight %}

We can also use this with the `funcs` library to get a type safe construction of a function.

{% highlight go %}
import . "github.com/katydid/katydid/relapse/combinator"
import . "github.com/katydid/katydid/funcs"

func main() {
	expr := NewStringEqual(NewStringVar(), NewStringConst("abc"))
	relapsePattern := In("a", Value(expr))
	g := G{"main": relapsePattern}
	relapseGrammar := g.Grammar()
}
{% endhighlight %}

### Constructing a Parser

A parser parses a specific serialization format or other parsable text or bytes.
We need to put our unparsed text, bytes or other structure into a parser so that it can be validated.

{% highlight go %}
import "github.com/katydid/katydid/parser/json"

func main() {
	jsonString := `{"a": "abc"}`
	jsonParser := json.NewJsonParser()
	if err := jsonParser.Init([]byte(jsonString)); err != nil {
		panic(err)
	}
}
{% endhighlight %}

We can also construct a protocol buffer parser.

{% highlight go %}
import protoparser "github.com/katydid/katydid/parser/proto"
import "github.com/gogo/protobuf/proto"

func main() {
	protoParser := protoparser.NewProtoNameParser("mypackage", "mymessage", &Mymessage{}.Description())
	msg := &Mymessage{A: "abc"}
	data, err := proto.Marshal(msg)
	if err != nil {
		panic(err)
	}
	if err := protoParser.Init(data); err != nil {
		panic(err)
	}
}
{% endhighlight %}

We can even construct a parser for a reflected go structure.

{% highlight go %}
import reflectparser "github.com/katydid/katydid/parser/reflect"
import "reflect"

func main() {
	reflectParser := reflectparser.NewReflectParser()
	s := &MyStruct{A: "abc"}
	v := reflect.ValueOf(s)
	reflectParser.Init(v)
}
{% endhighlight %}

### Validation

Now that we have a initialized parser and a relapse grammar we can validate the parsed tree against the schema.

{% highlight go %}
import "github.com/katydid/katydid/relapse/convert"
import "github.com/katydid/katydid/relapse/ast"
import "github.com/katydid/katydid/parser"
import "fmt"

func validate(grammar *relapse.Grammar, p parser.Interface) {
	compiled := convert.Compile(grammar)
	match := convert.Interpret(compiled, p)
	if !match {
		fmt.Printf("Expected match given %s\n", grammar.String())
	}
}
{% endhighlight %}